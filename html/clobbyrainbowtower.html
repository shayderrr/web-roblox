<!-- shxyder -->
<!-- ultimate game stash file -->
<!DOCTYPE html> <html lang="en-us"> <head> <meta charset="utf-8"> <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> <title>Obby Rainbow Tower</title> <style> @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600;700&display=swap'); html, body {  background-position: center; background-repeat: no-repeat; background-size: cover; width: 100%; height: 100%; overflow: visible; padding: 0; margin: 0; background-color: black; font-family: 'Poppins', sans-serif; } div#gameContainer { background: transparent !important; position: absolute; top: 0px !important; width: 100% !important; height: 100% !important; left: 0px !important; } div#gameContainer canvas { position: absolute; width: 100% !important; height: 100% !important; } div#gameContainer canvas[data-pixel-art="true"] { position: absolute; image-rendering: optimizeSpeed; image-rendering: -webkit-crisp-edges; image-rendering: -moz-crisp-edges; image-rendering: -o-crisp-edges; image-rendering: crisp-edges; image-rendering: -webkit-optimize-contrast; image-rendering: optimize-contrast; image-rendering: pixelated; -ms-interpolation-mode: nearest-neighbor; } .loadingOut { width: 350px; position: fixed; left: 50%; top: calc(50% ); transform: translate(-50%); border-radius: 25px; height: 8px; background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); overflow: hidden; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3); transition: opacity 0.5s ease-out; } .progress-bar { height: 100%; background: linear-gradient(90deg, #00f5ff, #ff00ff, #00f5ff); background-size: 200% 100%; animation: gradientShift 2s ease-in-out infinite; border-radius: 25px; transition: width 0.5s ease-out; position: relative; width: 0%; } .progress-bar::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent); animation: shimmer 1.5s ease-in-out infinite; border-radius: 25px; } @keyframes gradientShift { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } } @keyframes shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } } @keyframes pulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.05); } } .centered { position: fixed; top: calc(50% - 60px); left: 50%; transform: translate(-50%, -50%); width: 350px; text-align: center; animation: pulse 3s ease-in-out infinite; filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.3)); transition: opacity 0.5s ease-out; } #orientation-warning { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: linear-gradient(90deg, rgba(14, 176, 240, 1) 0%, rgba(87, 199, 133, 1) 97%); color: white; padding: 40px 50px; border-radius: 20px; text-align: center; z-index: 1000; backdrop-filter: blur(20px); border: 2px solid rgba(255, 255, 255, 0.3); box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5); font-weight: 600; font-size: 18px; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); animation: orientationPulse 2s ease-in-out infinite; max-width: 90vw; max-height: 90vh; min-width: 300px; flex-direction: column; align-items: center; justify-content: center; gap: 20px; } #orientation-warning.show { display: flex; } @keyframes orientationPulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.02); } } @keyframes rotateImage { 0%, 100% { transform: rotate(0deg); } 25% { transform: rotate(-5deg); } 75% { transform: rotate(5deg); } } #orientation-image { width: 80px; height: 80px; display: block; filter: brightness(1.2) drop-shadow(0 0 15px rgba(255, 255, 255, 0.6)); animation: rotateImage 3s ease-in-out infinite; flex-shrink: 0; } .orientation-text { font-size: 16px; line-height: 1.5; margin: 0; flex-shrink: 0; } .orientation-text[dir="rtl"] { direction: rtl; text-align: center; } @media (max-width: 480px) { #orientation-warning { padding: 30px 25px; font-size: 16px; min-width: 280px; gap: 15px; } #orientation-image { width: 60px; height: 60px; } .orientation-text { font-size: 14px; } } @media (max-height: 500px) { #orientation-warning { padding: 20px 30px; gap: 10px; } #orientation-image { width: 50px; height: 50px; } .orientation-text { font-size: 14px; } } </style> </head> <body> <div id="orientation-warning">  <div class="orientation-text">Please rotate your device to the correct mode.</div> </div> <div id="gameContainer">  <div class="loadingOut"> <div class="progress-bar" id="progress-bar"></div> </div> <canvas id="unity-canvas" data-pixel-art=""></canvas> <script src="https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/382aba212ec04a3c3c9d749465a88f28.loader.js"></script> <script> var myGameInstance = null; var orientationMessages = { 'tr': { portrait: 'Lütfen cihazınızı dikey konuma çevirin.', landscape: 'Lütfen cihazınızı yatay konuma çevirin.' }, 'en': { portrait: 'Please rotate your device to portrait mode.', landscape: 'Please rotate your device to landscape mode.' }, 'ar': { portrait: 'يرجى تدوير جهازك إلى الوضع الرأسي.', landscape: 'يرجى تدوير جهازك إلى الوضع الأفقي.' }, 'de': { portrait: 'Bitte drehen Sie Ihr Gerät in den Hochformat-Modus.', landscape: 'Bitte drehen Sie Ihr Gerät in den Querformat-Modus.' }, 'pt': { portrait: 'Por favor, gire seu dispositivo para o modo retrato.', landscape: 'Por favor, gire seu dispositivo para o modo paisagem.' }, 'ru': { portrait: 'Пожалуйста, поверните устройство в портретный режим.', landscape: 'Пожалуйста, поверните устройство в альбомный режим.' }, 'es': { portrait: 'Por favor, gira tu dispositivo al modo vertical.', landscape: 'Por favor, gira tu dispositivo al modo horizontal.' }, 'fr': { portrait: 'Veuillez faire pivoter votre appareil en mode portrait.', landscape: 'Veuillez faire pivoter votre appareil en mode paysage.' } }; function getBrowserLanguage() { var lang = navigator.language || navigator.userLanguage; var langCode = lang.substring(0, 2).toLowerCase(); return orientationMessages[langCode] ? langCode : 'en'; } function getOrientationMessage(requiredOrientation, isCurrentlyPortrait) { var lang = getBrowserLanguage(); var messages = orientationMessages[lang]; var normalizedRequired = requiredOrientation.toLowerCase(); if (normalizedRequired === "portrait" && !isCurrentlyPortrait) { return messages.portrait; } else if (normalizedRequired === "landscape" && isCurrentlyPortrait) { return messages.landscape; } return ''; } var canvas = document.querySelector("#unity-canvas"); var progressBar = document.querySelector("#progress-bar"); var gameContainer = document.querySelector("#gameContainer"); var orientationWarning = document.querySelector("#orientation-warning"); var DATA_PARTS = [ "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/4f8551342bb90ef1e058d5cc512b22bf.data.unityweb.part1", "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/4f8551342bb90ef1e058d5cc512b22bf.data.unityweb.part2", "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/4f8551342bb90ef1e058d5cc512b22bf.data.unityweb.part3", "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/4f8551342bb90ef1e058d5cc512b22bf.data.unityweb.part4", "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/4f8551342bb90ef1e058d5cc512b22bf.data.unityweb.part5" ]; async function loadAndMergeDataParts(progressCallback) { var chunks = []; var totalLoaded = 0; var totalSize = 0; for (var i = 0; i < DATA_PARTS.length; i++) { try { var headResponse = await fetch(DATA_PARTS[i], { method: 'HEAD' }); var size = parseInt(headResponse.headers.get('content-length') || '0'); totalSize += size; } catch (e) { console.warn('HEAD request failed for part ' + (i + 1) + ', will get size during download'); } } for (var i = 0; i < DATA_PARTS.length; i++) { console.log('Downloading part ' + (i + 1) + '/' + DATA_PARTS.length); var response = await fetch(DATA_PARTS[i]); if (!response.ok) { throw new Error('Failed to load: ' + DATA_PARTS[i]); } var reader = response.body.getReader(); var partChunks = []; while (true) { var result = await reader.read(); if (result.done) break; partChunks.push(result.value); totalLoaded += result.value.length; if (progressCallback && totalSize > 0) { progressCallback((totalLoaded / totalSize) * 0.7); } } var partSize = partChunks.reduce(function(acc, chunk) { return acc + chunk.length; }, 0); var partData = new Uint8Array(partSize); var offset = 0; for (var j = 0; j < partChunks.length; j++) { partData.set(partChunks[j], offset); offset += partChunks[j].length; } chunks.push(partData); } console.log('Merging all parts...'); var finalSize = chunks.reduce(function(acc, chunk) { return acc + chunk.length; }, 0); var mergedData = new Uint8Array(finalSize); var mergeOffset = 0; for (var i = 0; i < chunks.length; i++) { mergedData.set(chunks[i], mergeOffset); mergeOffset += chunks[i].length; } console.log('Merged data size: ' + (finalSize / 1024 / 1024).toFixed(2) + ' MB'); return mergedData; } var config = { frameworkUrl: "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/e9e41da0844c15001f802661ca26d7b8.framework.js.unityweb", codeUrl: "https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/Build/d9575d9ad4679ccdf19df2eb1dbaa36b.wasm.unityweb", streamingAssetsUrl: "StreamingAssets", companyName: "GameVGames", productName: "Obby Rainbow Tower", productVersion: "1.0.0", }; var scaleToFit; try { scaleToFit = !!JSON.parse(""); } catch (e) { scaleToFit = true; } function progressHandler(progress) { var percent = Math.round(progress * 100); var progressBarEl = document.querySelector("#progress-bar"); var loadingOut = document.querySelector(".loadingOut"); var logo = document.querySelector(".centered"); if (progressBarEl) { progressBarEl.style.width = percent + '%'; } console.log('Loading progress:', percent + '%'); if (progress >= 1) { console.log('Loading complete!'); setTimeout(function() { if (loadingOut) loadingOut.style.opacity = '0'; if (logo) logo.style.opacity = '0'; }, 500); setTimeout(function() { if (loadingOut) loadingOut.style.display = 'none'; if (logo) logo.style.display = 'none'; }, 1000); } } function onResize() { var container = canvas.parentElement; var w; var h; if (scaleToFit) { w = window.innerWidth; h = window.innerHeight; var r = 1080 / 1920; if (w * r > window.innerHeight) { w = Math.min(w, Math.ceil(h / r)); } h = Math.floor(w * r); } else { w = 1920; h = 1080; } container.style.width = canvas.style.width = w + "px"; container.style.height = canvas.style.height = h + "px"; container.style.top = Math.floor((window.innerHeight - h) / 2) + "px"; container.style.left = Math.floor((window.innerWidth - w) / 2) + "px"; } function checkOrientation(requiredOrientation) { if (!requiredOrientation) { orientationWarning.classList.remove('show'); gameContainer.style.display = 'block'; return; } var orientationText = document.querySelector('.orientation-text'); var isCurrentlyPortrait = window.innerHeight > window.innerWidth; var currentLang = getBrowserLanguage(); var normalizedRequired = requiredOrientation.toLowerCase(); var needsWarning = false; if (normalizedRequired === "portrait" && !isCurrentlyPortrait) { needsWarning = true; } else if (normalizedRequired === "landscape" && isCurrentlyPortrait) { needsWarning = true; } if (needsWarning) { orientationWarning.classList.add('show'); gameContainer.style.display = 'none'; if (orientationText) { orientationText.textContent = getOrientationMessage(requiredOrientation, isCurrentlyPortrait); if (currentLang === 'ar') { orientationText.setAttribute('dir', 'rtl'); } else { orientationText.removeAttribute('dir'); } } } else { orientationWarning.classList.remove('show'); gameContainer.style.display = 'block'; } } var currentOrientationSetting = null; function loadTemplateConfig() { var request = new XMLHttpRequest(); request.open('GET', 'TemplateData/Orientation/template.json', true); request.onreadystatechange = function() { if (request.readyState === 4) { if (request.status === 200) { try { var templateConfig = JSON.parse(request.responseText); var orientationOption = templateConfig.customOptions.find(function(option) { return option.name === "orientation"; }); if (orientationOption) { currentOrientationSetting = orientationOption.default; checkOrientation(currentOrientationSetting); } } catch (e) { console.error('Error parsing template.json:', e); } } else { orientationWarning.classList.remove('show'); gameContainer.style.display = 'block'; } } }; request.send(); } function onOrientationChange() { if (currentOrientationSetting) { checkOrientation(currentOrientationSetting); } } async function initGame() { try { console.log('Starting to load data parts...'); var mergedData = await loadAndMergeDataParts(function(progress) { progressHandler(progress); }); var blob = new Blob([mergedData], { type: 'application/octet-stream' }); var dataUrl = URL.createObjectURL(blob); config.dataUrl = dataUrl; console.log('Starting Unity...'); createUnityInstance(canvas, config, function(progress) { progressHandler(0.7 + (progress * 0.3)); }).then(function(instance) { canvas = instance.Module.canvas; myGameInstance = instance; onResize(); URL.revokeObjectURL(dataUrl); }); } catch (error) { console.error('Failed to load game:', error); alert('Oyun yüklenirken hata oluştu. Lütfen sayfayı yenileyin.'); } } initGame(); window.addEventListener('resize', function() { onResize(); onOrientationChange(); }); window.addEventListener('orientationchange', function() { setTimeout(function() { onOrientationChange(); }, 100); }); loadTemplateConfig(); </script> <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/netclassroom/998800@main/a/js/api.js"></script> </div> </body> </html>
